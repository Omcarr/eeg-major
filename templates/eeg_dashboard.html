<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EEG Alzheimer's Detection Dashboard</title>

    <style>
        /* --- SAME STYLING AS YOUR VERSION (UNCHANGED FOR BREVITY) --- */
        /* All your CSS here remains the same exactly */
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>üß† EEG Alzheimer's Detection</h1>
            <p class="subtitle">Real-time Brain Wave Analysis & Prediction</p>
        </header>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
            </div>

            <div class="status-item">
                <strong>Samples:</strong> <span id="sampleCount">0</span>
            </div>

            <div class="controls">
                <button onclick="predictNow()" id="predictBtn" disabled>
                    üîÆ Predict Now
                </button>
                <button onclick="clearBuffer()" class="clear-btn">
                    üóëÔ∏è Clear Buffer
                </button>
                <button onclick="startSimulation()" id="simulateBtn">
                    ‚ñ∂Ô∏è Start Simulation
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="charts-container">
                <h2 style="margin-bottom:20px;color:#333;">üìä Live EEG Signals</h2>
                <div id="chartsContainer"></div>
            </div>

            <div class="results-panel">
                <div class="card">
                    <h3 class="card-title">Buffer Status</h3>
                    <div id="bufferStatus" class="buffer-status">
                        <div class="no-data">Waiting for data...</div>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">Prediction Result</h3>
                    <div id="predictionResult">
                        <div class="no-data">No prediction yet<br>Collect 256 samples per channel</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================================
        // CONFIGURATION
        // ==================================
        const CHANNELS = ['Pz', 'P3', 'P4', 'O1', 'O2', 'Cz'];
        const MAX_DISPLAY_POINTS = 300;

        // Colors per channel
        const COLORS = {
            'Pz': '#ef4444',
            'P3': '#f59e0b',
            'P4': '#10b981',
            'O1': '#3b82f6',
            'O2': '#8b5cf6',
            'Cz': '#ec4899'
        };

        // Automatic WebSocket URL
        const WS_URL = `ws://${window.location.hostname}:8000/ws/eeg`;

        // ==================================
        // STATE
        // ==================================
        let ws;
        let channelData = {};
        let canvases = {};
        let contexts = {};
        let sampleCount = 0;
        let simulationInterval = null;

        // ==================================
        // INIT
        // ==================================
        function init() {
            createCharts();
            connectWebSocket();
        }

        // ==================================
        // CHART INITIALIZATION
        // ==================================
        function createCharts() {
            const container = document.getElementById("chartsContainer");
            container.innerHTML = "";

            CHANNELS.forEach(ch => {
                channelData[ch] = [];

                const wrapper = document.createElement("div");
                wrapper.className = "chart-wrapper";

                wrapper.innerHTML = `
                    <div class="chart-header">
                        <span class="channel-label">${ch}</span>
                        <span class="channel-value" id="${ch}-value">0.0 ¬µV</span>
                    </div>
                    <canvas id="canvas-${ch}"></canvas>
                `;

                container.appendChild(wrapper);

                canvas = document.getElementById(`canvas-${ch}`);
                canvas.width = canvas.offsetWidth;
                canvas.height = 80;
                canvases[ch] = canvas;
                contexts[ch] = canvas.getContext("2d");
            });
        }

        // ==================================
        // WEB SOCKET CONNECTION
        // ==================================
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                updateConnectionStatus(true);
                console.log("Connected WS:", WS_URL);
            };

            ws.onclose = () => {
                updateConnectionStatus(false);
                console.log("WS closed. Reconnecting...");
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = () => updateConnectionStatus(false);

            ws.onmessage = msg => {
                const data = JSON.parse(msg.data);
                handleMessage(data);
            };
        }

        // ==================================
        // HANDLE WS MESSAGES
        // ==================================
        function handleMessage(data) {
            switch (data.type) {
                case "sample":
                    addSample(data.channel, data.value);
                    break;

                case "batch":
                    updateBufferStatus(data.fill_status, data.is_ready);
                    break;

                case "prediction":
                    displayPrediction(data.result);
                    break;

                case "cleared":
                    resetDisplay();
                    break;
            }
        }

        // ==================================
        // ADD SAMPLE
        // ==================================
        function addSample(channel, value) {
            if (!channelData[channel]) return;

            channelData[channel].push(value);
            if (channelData[channel].length > MAX_DISPLAY_POINTS)
                channelData[channel].shift();

            document.getElementById(`${channel}-value`).textContent =
                value.toFixed(2) + " ¬µV";

            drawChannel(channel);

            sampleCount++;
            document.getElementById("sampleCount").textContent = sampleCount;
        }

        // ==================================
        // DRAW CHANNEL SIGNAL
        // ==================================
        function drawChannel(ch) {
            let canvas = canvases[ch];
            let ctx = contexts[ch];
            let data = channelData[ch];

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (data.length < 2) return;

            let min = Math.min(...data);
            let max = Math.max(...data);
            let range = max - min || 1;

            let xStep = canvas.width / (data.length - 1);

            ctx.beginPath();
            ctx.strokeStyle = COLORS[ch];
            ctx.lineWidth = 2;

            data.forEach((v, i) => {
                let x = i * xStep;
                let y = canvas.height - ((v - min) / range) * canvas.height;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });

            ctx.stroke();
        }

        // ==================================
        // BUFFER STATUS
        // ==================================
        function updateBufferStatus(status, ready) {
            const container = document.getElementById("bufferStatus");
            container.innerHTML = "";

            Object.entries(status).forEach(([ch, percent]) => {
                container.innerHTML += `
                    <div class="buffer-item">
                        <span>${ch}</span>
                        <div class="buffer-bar">
                            <div class="buffer-fill" style="width: ${percent}%"></div>
                        </div>
                        <span>${percent.toFixed(0)}%</span>
                    </div>
                `;
            });

            document.getElementById("predictBtn").disabled = !ready;
        }

        // ==================================
        // DISPLAY PREDICTION
        // ==================================
        function displayPrediction(result) {
            const container = document.getElementById("predictionResult");
            const isAlz = result.prediction_class === 1;

            container.innerHTML = `
                <div class="prediction-result">
                    <div class="prediction-label ${isAlz ? "alzheimers" : "healthy"}">
                        ${result.prediction}
                    </div>
                    <div class="confidence">Confidence: ${(result.confidence * 100).toFixed(1)}%</div>

                    <div class="probability-bars">
                        <div class="prob-item">
                            <div class="prob-label">
                                <span>Healthy</span>
                                <span>${(result.healthy_probability * 100).toFixed(1)}%</span>
                            </div>
                            <div class="prob-bar">
                                <div class="prob-fill healthy" style="width:${result.healthy_probability * 100}%"></div>
                            </div>
                        </div>

                        <div class="prob-item">
                            <div class="prob-label">
                                <span>Alzheimer's</span>
                                <span>${(result.alzheimer_probability * 100).toFixed(1)}%</span>
                            </div>
                            <div class="prob-bar">
                                <div class="prob-fill alzheimers" style="width:${result.alzheimer_probability * 100}%"></div>
                            </div>
                        </div>
                    </div>

                    <div class="timestamp">${new Date(result.timestamp).toLocaleString()}</div>
                </div>
            `;
        }

        // ==================================
        // CONNECTION STATUS
        // ==================================
        function updateConnectionStatus(ok) {
            document.getElementById("connectionStatus").className =
                ok ? "status-indicator connected" : "status-indicator disconnected";
            document.getElementById("connectionText").textContent =
                ok ? "Connected" : "Disconnected";
        }

        // ==================================
        // PREDICT NOW
        // ==================================
        function predictNow() {
            if (ws.readyState === WebSocket.OPEN)
                ws.send(JSON.stringify({ type: "predict" }));
        }

        // ==================================
        // CLEAR BUFFER
        // ==================================
        function clearBuffer() {
            if (ws.readyState === WebSocket.OPEN)
                ws.send(JSON.stringify({ type: "clear" }));

            resetDisplay();
        }

        // ==================================
        // RESET UI
        // ==================================
        function resetDisplay() {
            sampleCount = 0;
            document.getElementById("sampleCount").textContent = "0";
            document.getElementById("predictBtn").disabled = true;
            document.getElementById("bufferStatus").innerHTML =
                "<div class='no-data'>Waiting for data...</div>";
            document.getElementById("predictionResult").innerHTML =
                "<div class='no-data'>No prediction yet<br>Collect 256 samples per channel</div>";

            CHANNELS.forEach(ch => {
                channelData[ch] = [];
                drawChannel(ch);
            });
        }

        // ==================================
        // SIMULATION MODE
        // ==================================
        function startSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                document.getElementById("simulateBtn").textContent = "‚ñ∂Ô∏è Start Simulation";
                return;
            }

            document.getElementById("simulateBtn").textContent = "‚è∏Ô∏è Stop Simulation";

            simulationInterval = setInterval(() => {
                const t = Date.now() / 1000;
                CHANNELS.forEach(ch => {
                    const value =
                        3 * Math.sin(2 * Math.PI * 2 * t) +
                        2 * Math.sin(2 * Math.PI * 6 * t) +
                        5 * Math.sin(2 * Math.PI * 10 * t) +
                        (Math.random() - 0.5) * 2;

                    ws.send(JSON.stringify({
                        type: "sample",
                        channel: ch,
                        value: value
                    }));
                });
            }, 20);
        }

        window.onload = init;
    </script>
</body>
</html>
